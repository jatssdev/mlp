<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test</title>
    <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tsparticles@1.17.9/dist/tsparticles.min.js"></script>
</head>

<body>
    <div id="tsparticles" style="width: 100vw; height: 100vh;"></div>
    <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.min.js"></script>

    <script src="./script.js">
        let simplex;
        let size;
        let columns;
        let rows;
        let w;
        let h;
        let field;
        let noiseZ;

        function setup(container) {
            size = 20;
            noiseZ = 0;
            initSimplex(); // Initialize simplex noise
            reset(container);
            window.addEventListener("resize", () => reset(container));
        }

        function initSimplex() {
            simplex = new SimplexNoise(Math.random); // Initialize simplex noise object
        }

        function initField() {
            field = new Array(columns);
            for (let x = 0; x < columns; x++) {
                field[x] = new Array(rows); // Fixed: Changed to 'rows' instead of 'columns'
                for (let y = 0; y < rows; y++) {
                    field[x][y] = [0, 0];
                }
            }
        }

        function calculateField() {
            for (let x = 0; x < columns; x++) {
                for (let y = 0; y < rows; y++) {
                    let angle = simplex.noise3D(x / 50, y / 50, noiseZ) * Math.PI * 2;
                    let length = simplex.noise3D(x / 100 + 40000, y / 100 + 40000, noiseZ);
                    field[x][y][0] = angle;
                    field[x][y][1] = length;
                }
            }
        }

        function reset(container) {
            w = container.canvas.size.width;
            h = container.canvas.size.height;
            columns = Math.floor(w / size) + 1;
            rows = Math.floor(h / size) + 1;
            initField();
        }

        function drawField(ctx) {
            for (let x = 0; x < columns; x++) {
                for (let y = 0; y < rows; y++) {
                    let angle = field[x][y][0];
                    let length = field[x][y][1];
                    ctx.save();
                    ctx.translate(x * size, y * size);
                    ctx.rotate(angle);
                    ctx.strokeStyle = "white";
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, size * length);
                    ctx.stroke();
                    ctx.restore();
                }
            }
        }

        tsParticles.load("tsparticles", {
            background: {
                color: {
                    value: "#000"
                }
            },
            fpsLimit: 120,
            particles: {
                number: {
                    value: 200,
                    density: {
                        enable: true,
                        value_area: 800
                    }
                },
                color: {
                    value: ["#5bc0eb", "#fde74c", "#9bc53d", "#e55934", "#fa7921"]
                },
                shape: {
                    type: "square",
                    stroke: {
                        width: 0,
                        color: "#000000"
                    }
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 5
                },
                line_linked: {
                    enable: false,
                    distance: 150,
                    color: "#ffffff",
                    opacity: 0.4,
                    width: 1
                },
                move: {
                    enable: true,
                    speed: 1,
                    direction: "none",
                    random: false,
                    straight: false,
                    outMode: "out",
                    bounce: false,
                    warp: true,
                    noise: {
                        enable: true,
                        delay: {
                            value: 0
                        }
                    },
                    trail: {
                        enable: false,
                        color: {
                            value: "#000"
                        },
                        length: 30
                    }
                }
            },
            interactivity: {
                detect_on: "canvas",
                events: {
                    resize: true
                }
            },
            detectRetina: true,
            pauseOnBlur: true
        }).then((container) => {
            container.setNoise({
                init: function () {
                    setup(container);
                },
                update: function () {
                    calculateField();
                    noiseZ += 0.004;
                    drawField(container.canvas.context);
                },
                generate: function (p) {
                    const pos = p.getPosition();

                    const px = Math.max(Math.floor(pos.x / size), 0);
                    const py = Math.max(Math.floor(pos.y / size), 0);

                    if (!field || !field[px] || !field[px][py]) {
                        return { angle: 0, length: 0 };
                    }

                    return {
                        angle: field[px][py][0],
                        length: field[px][py][1]
                    };
                }
            });

            container.refresh();
        });

    </script>
</body>

</html>